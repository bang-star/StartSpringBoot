# 02. Spring Data JPA 맛보기

  - 웹 기반의 프로젝트에서 데이터베이스를 처리하는 작업은 절대적으로 중요한 위치를 차지한다.

  - 스프링 프레임워크는 기존의 다른 프레임워크들과의 통합이 가능하다.

    - 스프링 프레임워크는 기본적으로 다른 프레임워크들과의 대립이 아닌 융합을 선택했기 때문에 각종 프레임워크들과의 통합을 위한 '어댑터(Adapter)'들을 지원합니다.

  - 과거 JDBC에서 ORM(Object Relational Mapping)까지 'Spring Data'라는 하위 프로젝트를 통해서 다양한 방식의 개발을 지원하고 있다.

  - Spring Data JPA는 JPA(Java Persistence API)라는 기술을 스프링에서 개발할 수 있도록 지원하는 라이브러리이다.

    - 다양한 데이터베이스에 종속적인 SQL문 없이도 개발이 가능하기 때문에 개발의 생산성을 높일 수 있다.

<br />

## 2.1 JPA 소개

  - JPA
    
     - Java Persistence API의 약자로, Java 관련 기술 스펙의 하나이다.

     - Java를 이용해서 데이터를 관리(유지)하는 기법을 하나의 스펙으로 정리한 표준

     - 데이터베이스와 관련된 기술과 스펙은 오랫동안 이슈가 되어 왔었고, Java 진영에서는 EJB라는 기술 스펙에서 Entity Bean이라는 데이터를 처리하는 스펙을 정한 것이 JPA의 시초라 할 수 있다.

  - JPA를 이해하기 위해 ORM(Object Relational Mapping)에 대한 이해가 필요하다.

  - ORM
    
     - 객체지향에서 말하는 객체와 데이터베이스에서 말하는 개체가 상당히 유사하다는 입장에서 시작한다.
     
     <br />

     <img src="https://user-images.githubusercontent.com/63120360/181025936-bc876463-e089-4d51-9d29-1d1d47ee3c99.jpg">

     - 예를 들어 회원 정보를 생각해보면 객체지향에서 클래스로 설계하는 모습과 데이터베이스의 테이블 구조가 거의 유사하다는 것을 볼 수 있다.

     - 유사한 점들이 ORM에서는 말하는 '데이터베이스와 객체지향을 한 번에 처리할 수 있지 않을까'라는 생각으로 시작하게 됩니다.

     - ORM은 특정한 언어에 종속적인 개념이 아니다. 즉, 다른 언어에서도 ORM 관련 프레임워크들이 많이 존재하듯이 ORM 자체는 객체지향과 관계형 데이터베이스를 매핑시킨다는 추상적인 개념이다.

     - ORM이 일종의 비전(vision)에 불과했다면, JPA는 Java에서 이를 구현하기 위한 상세화한 통과 기준이라고 볼 수 있습니다.

     > 기존의 JDBC 등을 이용해서 직접 구현했던 데이터베이스 관련 작업을 대신 처리해 주는 추상화된 계층의 구현 스펙이라고 할 수 있습니다.

     <img src="https://user-images.githubusercontent.com/63120360/181030934-87c84d04-5289-412a-abfe-0148fe846cb2.png">

  <br />

  - JPA를 이용하면 데이터베이스에 대한 처리를 JPA 계층에서 처리하기 때문에 추상화된 형태의 코드를 제작하는 것만으로 개발이 가능하다.

  - JPA 그 자체로는 스펙에 불과하기 때문에 이를 실제로 구현한 제품이나 프레임워크들의 존재가 필수적이다. 

    - 예를 들어, Servlet이라는 기술 스펙을 Tomcat에서 구현한 것처럼, JPA를 구현한 구현체 중에서 스프링 부트 프로젝트에서는 Hibernate라는 것을 이용한다.
  
  <br />

  <img src="https://user-images.githubusercontent.com/63120360/181032255-4e1d9dc6-23ae-4d27-9a39-426882274bf1.png">

  <br />

  - JPA의 장점

    1. 데이터베이스 관련 코드에 대해 유연함을 얻을 수 있다.

       데이터베이스 변경은 기존의 소스 코드에 치명적인 영향을 미친다. 데이터베이스가 변경되면 이를 사용하는 SQL이 변경되고, DAO나 서비스, 화면까지 영향을 미치게 된다. 반면에 JPA를 이용하면 테이블 생성 등과 같은 작업부터 변경되는 DB 설계와 JAVA 설계를 한 번에 처리할 수 있어서 익숙해진다면 빠른 생산성을 얻을 수 있다.

    2. 데이터베이스와 독립적인 관계이다.

       JPA는 특정 벤더(회사)의 데이터베이스에 종속적이지 않기 때문에 개발자들은 데이터베이스 제품이 변경되거나 버전이 변경되는 것과 같은 골치 아픈 일에서 자유로워질 수 있다.

  - JPA의 단점

    1. 학습 곡선(learning curve)이 크다.

       기존의 데이터베이스 위주 학습에 비해서 새롭게 배워야 하는 기능들이 많다. 
       
       새로운 개념과 기술을 익히는 학습 곡선이 크기 때문에 선뜻 쉽게 적용하기가 어렵다.

    2. 근본적인 객체지향 설계 사상이 반영되어야 합니다.

       JPA는 '어떻게 적합한 객체들의 관계를 작성할 것인가?'라는 프로젝트의 성패를 좌우합니다. 
       
       이 과정에서 충분할 설계와 검토 과정을 거쳐야 하는데 현실적으로 바쁜 일정이나 개발의 숙련도 등의 다양한 문제들을 극복해야만 한다.

    3. 특정 데이터베이스의 강력함을 활용할 수 없다는 문제가 있다.
       
       JPA를 이용하면 SQL 튜닝 등의 작업에 제약이 생길 수 있다. JPA에는 native SQL이라는 기능을 지원해서 기존의 SQL을 재사용할 수 있는 방법이 있지만, 이 경우 데이터베이스에 독립적인 개발이 불가능하기 때문에 JPA의 장점을 잃는 한계를 가지게 됩니다.

    <br />

    <img src="https://user-images.githubusercontent.com/63120360/181034815-d46b28c2-0f95-4362-aaa6-807c18c5157f.png">

    <br />

  - JPA를 이용하면 Java로 작성된 클래스, 객체들과 데이터베이스상에 테이블, 레코드들을 자동으로 관리하게 됩니다.

  - 개발자는 별도의 SQL을 작성할 필요 없이, 원하는 객체지향의 구조를 설계하는 것만으로 모든 개발을 끝낼 수 있다.

  - Java 쪽의 메모리 상태와 데이터베이의 상태를 관리해야하기 때문에 이에 대한 상태 등에 대해서 별도의 용어들을 이용해서 표현합니다.

<br />

## 2.1.1 엔티티(Entity), 엔티티 매니저(Entity Manager)

  - Entity는 데이터베이스상에서 데이터로 관리하는 대상을 의미합니다.

    예를들어 '상품', '회사', '직원' 등과 같이 명사이면서 업무와 관련된 데이터를 엔티티로 규정합니다.

    데이터베이스에서는 엔티티를 위해서 일반적으로 테이블을 설계하고, 데이터를 추가합니다. 이렇게 추가된 데이터는 인스터스 또는 레코드라고 부른다.

  - JPA에서는 Java를 이용해서 엔티티들을 관리하기 때문에 엔티티 타입의 존재는 클래스가 됩니다. 

    예를 들어, JPA에서 '하나의 엔티티 타입을 생성한다'라는 의미는 하나의 클래스'를 작성한다는 의미가 된다.

    <img src="https://user-images.githubusercontent.com/63120360/181051016-4c196aca-ce49-4417-a8e9-88b3f98abd66.png">

<br />

  - JPA를 공부하면서 주의할 점은 '엔티티'라는 용어가 때로는 클래스를 의미할 경우도 있지만, 때로는 인스턴스를 의미하는 경우도 있다.

    예를들어, '회원 엔티티'가 회원 클래스를 의미하는 경우와 회원 클래스에 생성된 인스턴스를 의미하는 경우가 있다.

    '회원 엔티티 클래스'와 '회원 엔티티 인스턴스' 혹은 '회원 엔티티 객체'라는 표현이 정확하지만, 혼용되는 경우가 많다.

  - 엔티티 매니저
    
     - 여러 엔티티 객체들을 관리하는 역할을 한다.

     - '관리'는 'Life Cycle'을 의미한다.

     - 엔티티 매니저는 자신이 관리해야 하는 엔티티 객체들을 '영속 컨텍스트(Persistence Context)'라는 곳에 넣어두고, 객체들의 생사를 관리한다.

    <img src="https://user-images.githubusercontent.com/63120360/181052157-847d76cd-c716-4514-9937-68b6dc7009ac.png">

<br />
<hr />
<br />

## 2.1.2 영속 컨텍스트(Persistence Context)와 엔티티 객체

  - 영속 컨텍스트는 JPA가 엔티티 객체들을 모아두는 '공간'이라고 이해할 수 있다.

  - 컨텍스트라는 용어는 하나의 공간이나 울타리라는 개념으로 이해하는 것이 좋다.

  - 엔티티 객체는 다음과 같은 상태로 구분될 수 있다.

    <image src="https://user-images.githubusercontent.com/63120360/181052864-ae4f72f5-b379-43d4-a7c4-16bbabda3e16.png">

    <br />

    - 화살표에 있는 메소드는 엔티티 매니저를 통해서 실행되는 메소드입니다.

      - New(비영속)
        
        Java 영역에 객체만 존재하고, 데이터베이스와 연동된 적이 없는 상태

        엔티티 매니저의 관리하에 있는 것이 아니기 때문에 순수한 Java 객체이다.

      - Managed(영속)

        데이터베이스에 저장되고, 메모리상에서도 같은 상태로 존재하는 상태.

        객체는 영속 컨텍스트 내에 들어가게 되고, id(PK) 값을 통해서 필요한 엔티티 객체를 꺼내 사용할 수 있게 됩니다.

      - Removed(삭제)
        
        데이터베이스상에서 삭제된 상태.

        객체는 더 이상 영속 컨텍스트에 존재하지 않습니다.

      - Detached(준영속)

        영속 컨텍스트에서 엔티티 객체를 꺼내서 사용하는 상태.

        준영속 상태의 객체는 고유한 id(PK)를 가지고 있지만, 아직 데이터베이스와 동기화가 이루어지지 않은 상태

<br />

## 2.1.3 기존의 JPA 개발과 Spring Data JPA

  - JPA를 이용해서 개발하는 과정이 조금 복잡하다. 
  
  - JPA에서는 EntityManager라는 존재를 이용해서 '영속성'이라는 것을 관리하기 때문이다.

  ```Java
  EntityManagerFatory emfactory = Persistence.createEntityManagerFactory("My_JPA");

  EntityManager entitymanager = emfactory.createEntityManager();
  entitymanager.getTransaction().begin();

  Employee employee = ...

  ...

  entitymanager.persist(employee);
  entitymanager.getTransaction().commit();
  entitymanager.close();
  emfactory.close();
  ```

  - EntityManager를 이용하여 객체를 보관(persist)한다.

  - 트랜잭션에 대한 관리가 필요하고, close() 메소드들을 이용하여 사용한 자원을 정리해준다.

  - Spring Data JPA의 경우에는 이러한 처리 없이 다음과 같은 형태의 개발을 목표로 합니다.

  ```Java
  public interface CustomerRepository extends CrudRepository<Customer, Long> {

    List<Customer> findByLastName(String lastName);

    Customer findById(long id);
  }
  ```

  - 기존에 Java를 공부할 때에는 Java에서 인터페이스를 설계하고, 이를 구현하는 클래스를 만드는 것이 일반적이지만, Spring Data JPA는 동적으로 인터페이스를 구현하는 클래스를 만들어 내는 방식(동적 프록시, Dynamic Proxy)을 이용해서 실제 클래스를 작성하지 않아도 자동으로 만들어지기 때문에 별도의 코드를 작성할 필요가 없다.
